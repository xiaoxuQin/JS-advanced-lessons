<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>LS07</title>
    <!--<script src="./js/demo01.js"></script>-->
    <!--<script src="./js/demo02.js"></script>-->
    <!--<script src="./js/demo03.js"></script>-->
    <!--<script src="./js/demo04.js"></script>-->
</head>
<body>
    <script>
        // 函数名声明： 变量提升， sum(1, 2);可以放在前面
        // 变量的定义会被解释器提升
        function sum(x,y){
            return x + y;
        }
        sum(1, 2);

        // 匿名函数
        window.onload = function(){
            alert("页面加载完成");
        }

        // sum1(1,2); 放在前面的话会报错
        var sum1 = function(x,y){
            return x + y;
        }
        sum1(1,2);

        // new 一个function
        // 使用 Function 构造函数来实例化得到一个function
        // Function 实例化的函数，执行效率相对降低，但是更加灵活
        var fn1 = new Function('x', 'y', 'return x + y');
        fn1(1, 2);
    </script>

    <script>
        // 2. 作为方法调用（this为调用此方法的对象）
        var obj = {
            x: 0,
            // test内部的this指向调用该方法的对象
            test : function(){
                console.log(this.x);
            }
        }
        obj.test();
    
        // 3. 通过call( )和apply( )间接调用
        //（this为函数对象的call/apply方法的首个参数，移花接木）
        var objA = {"objName":"AAA"};
        var objB = {"objName":"BBB"};
        objA.foo = function(){
            console.log(this.ocjName);
        }
        objA.foo();
        // 方法名.call(对象) 可以切换方法调用的对象
        // apply() 传参时会有不同
        objA.foo.call(objB); 
        // 可以让objB调用objA的方法，
        // 切换调用对象

        // 4. 作为构造函数的调用
        // function Person(username) {
        //     this.username = username;
        //     this.sayHi = function(){
        //         console.log(this.username);
        //     }
        // }
        function Person(username) {
            this.username = username;
            }
        Person.prototype.sayHi = function(){
                console.log(this.username);
        }
        //指向构造函数实例化出来的对象
        var person = new Person("zhangsan");
        console.log(person.__proto__ === Person.prototype );
        // true
        //Person.prototype 里面的方法，是所有它实例化了的对象共用的
    </script>

        // 函数参数的数量问题
    <script>
        function test(){
            var s = "";
            // arguments 获取函数传入的实参，是个类数组对象
            for(var i = 0; i < arguments.length; i++){
                s += arguments[i];
            }
            return s;
            }
        test("hello,", "world!");
    </script>

        // 参数类型与传递方式（值、 引用）
    <script>
        var a = 2;
        function foo(x){
            x = 1;
            console.log(a,x);  // 2 1
        }
        foo(a);
        console.log(a);     // 2
        
// sources snippet
// ctrl + enter 执行
        var obj = {x: 0};
        function bar(obj1){
            obj1.x = 2;
            console.log(obj, obj1);
            // {x: 2}  {x: 2}
        }
        bar(obj);
    </script>

    <script>
        var obj = {"userName":"zhangsan", "age":20}
    // 定义一个函数完成对变量的复制过程，
    // 当成新的变量，并返回
    // 引用类型时，数组、对象
        function copyArg(arg1){
            var copy;
            switch(true){
                case (arg1 instanceof String):
                    copy = arg1;
                    break;
                case (arg1 instanceof Number):
                    copy = arg1;
                    break;
                case (arg1 instanceof Boolean): 
                    copy = arg1;
                    break;
                case (arg1 instanceof Array): 
                    copy = [];
                    for(var i = 0; i < arg1.length; i++){
                        copy[i] = arg1[i];
                    }
                    break;
            }
        }    
    </script>

    <script>
        var str = "abc";
        console.log(str instanceof Object); //  false
        var str = "abc";
        var strObject = new Object(str);
        console.log(strObject instanceof Object);     //  true
    </script>
</body>
</html>